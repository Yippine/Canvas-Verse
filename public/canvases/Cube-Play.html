<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D é­”è¡“æ–¹å¡Š MVP</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: 'Arial', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }

        /* UI è¦†è“‹å±¤ */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none; /* è®“æ»‘é¼ å¯ä»¥ç©¿é€é»æ“Šåˆ° canvas */
            user-select: none;
        }

        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: #ffd700; }
        p { margin: 5px 0; font-size: 0.9rem; opacity: 0.9; }
        .key { display: inline-block; background: #444; padding: 2px 6px; border-radius: 4px; font-family: monospace; border: 1px solid #666; }

        /* æ§åˆ¶é¢æ¿ */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
        }

        button {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }

        button:hover { background: #555; }
        button:active { background: #777; }
        button.action-btn { background: #2c3e50; border-color: #34495e; font-weight: bold; }
        button.action-btn:hover { background: #34495e; }

        /* è¼‰å…¥æç¤º */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            display: none;
        }
    </style>
    <!-- å¼•å…¥ Three.js å’Œ ä¾è³´ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="loading">è¼‰å…¥ä¸­...</div>

    <div id="ui-container">
        <h1>3D é­”è¡“æ–¹å¡Šæ¨¡æ“¬å™¨ (MVP)</h1>
        <p>è¦–è§’æ§åˆ¶ï¼šæ»‘é¼ å·¦éµæ‹–æ›³æ—‹è½‰ï¼Œæ»¾è¼ªç¸®æ”¾</p>
        <p>éµç›¤æ“ä½œ (å€åˆ†å¤§å°å¯«)ï¼š</p>
        <p><span class="key">R</span> å³å±¤é †æ™‚é‡ <span class="key">L</span> å·¦å±¤é †æ™‚é‡</p>
        <p><span class="key">U</span> é ‚å±¤é †æ™‚é‡ <span class="key">D</span> åº•å±¤é †æ™‚é‡</p>
        <p><span class="key">F</span> å‰å±¤é †æ™‚é‡ <span class="key">B</span> å¾Œå±¤é †æ™‚é‡</p>
        <p>æŒ‰ä½ <span class="key">Shift</span> + æŒ‰éµ = é€†æ™‚é‡</p>
    </div>

    <div id="controls">
        <button onclick="cubeApp.scramble()">ğŸ”€ æ‰“äº‚ (Scramble)</button>
        <button onclick="cubeApp.reset()">ğŸ”„ é‚„åŸ (Reset)</button>
        <div style="width: 10px;"></div> <!-- Spacer -->
        <button onclick="cubeApp.rotateLayer('U', -1)">U (ä¸Š)</button>
        <button onclick="cubeApp.rotateLayer('D', -1)">D (ä¸‹)</button>
        <button onclick="cubeApp.rotateLayer('L', -1)">L (å·¦)</button>
        <button onclick="cubeApp.rotateLayer('R', -1)">R (å³)</button>
        <button onclick="cubeApp.rotateLayer('F', -1)">F (å‰)</button>
        <button onclick="cubeApp.rotateLayer('B', -1)">B (å¾Œ)</button>
    </div>

<script>
/**
 * Rubik's Cube Logic
 * * åº§æ¨™ç³»å®šç¾© (Three.js):
 * x: å³ (+), å·¦ (-)
 * y: ä¸Š (+), ä¸‹ (-)
 * z: å‰ (+), å¾Œ (-)
 */

class RubiksCubeApp {
    constructor() {
        this.container = document.getElementById('canvas-container');
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.cubies = []; // å­˜å„²æ‰€æœ‰ 27 å€‹å°æ–¹å¡Š
        this.isAnimating = false; // é˜²æ­¢å‹•ç•«é‡ç–Š
        this.pivot = new THREE.Object3D(); // ç”¨æ–¼æ—‹è½‰çš„è»¸å¿ƒç‰©ä»¶

        // é­”æ–¹åƒæ•¸
        this.cubeSize = 1;
        this.spacing = 0.02; // å°æ–¹å¡Šä¹‹é–“çš„é–“éš™

        // é¡è‰²å®šç¾© (Hex) - åœ‹éš›æ¨™æº–é…è‰²
        // Right(x+): Red, Left(x-): Orange
        // Top(y+): Yellow, Bottom(y-): White
        // Front(z+): Green, Back(z-): Blue
        this.colors = {
            right: 0xB90000,  // Red
            left: 0xFF5900,   // Orange
            top: 0xFFD500,    // Yellow
            bottom: 0xFFFFFF, // White
            front: 0x009E60,  // Green
            back: 0x0045AD,   // Blue
            core: 0x282828    // å…§éƒ¨é»‘è‰²
        };

        this.init();
    }

    init() {
        // 1. å ´æ™¯è¨­ç½®
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x333333);

        // 2. ç›¸æ©Ÿè¨­ç½®
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        this.camera.position.set(5, 5, 7);
        this.camera.lookAt(0, 0, 0);

        // 3. æ¸²æŸ“å™¨è¨­ç½®
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.container.appendChild(this.renderer.domElement);

        // 4. ç‡ˆå…‰ (ç°¡å–®çš„ç’°å¢ƒå…‰ + æ–¹å‘å…‰ä»¥é¡¯ç¤ºç«‹é«”æ„Ÿ)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        this.scene.add(dirLight);

        // 5. æ§åˆ¶å™¨ (OrbitControls)
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enablePan = false; // ç¦æ­¢å¹³ç§»ï¼Œä¿æŒé­”æ–¹åœ¨ä¸­å¿ƒ

        // 6. ç”Ÿæˆé­”æ–¹
        this.createCube();
        this.scene.add(this.pivot); // åŠ å…¥æ—‹è½‰è»¸å¿ƒåˆ°å ´æ™¯

        // 7. ç¶å®šäº‹ä»¶
        window.addEventListener('resize', () => this.onWindowResize(), false);
        window.addEventListener('keydown', (e) => this.onKeyDown(e), false);

        // 8. é–‹å§‹æ¸²æŸ“å¾ªç’°
        this.animate();
    }

    // å‰µå»º 3x3x3 é­”æ–¹
    createCube() {
        // æ¸…é™¤èˆŠçš„ (å¦‚æœæ˜¯é‡ç½®)
        if (this.cubies.length > 0) {
            this.cubies.forEach(c => this.scene.remove(c));
            this.cubies = [];
        }

        const geometry = new THREE.BoxGeometry(this.cubeSize, this.cubeSize, this.cubeSize);
        // ç‚ºäº†ç¾è§€ï¼Œç¨å¾®åœ“è§’åŒ– (é€™è£¡ç”¨ç°¡å–®çš„ boxï¼Œè‹¥è¦åœ“è§’éœ€ç”¨ RoundedBoxGeometryï¼Œç‚ºæ±‚ MVP ç°¡åŒ–ä½¿ç”¨ Box)

        // å»ºç«‹ 3x3x3 ç¶²æ ¼
        // åº§æ¨™ç¯„åœå¾ -1 åˆ° 1
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    const materials = this.getMaterials(x, y, z);
                    const mesh = new THREE.Mesh(geometry, materials);

                    // è¨­å®šä½ç½® (åŠ ä¸Šé–“éš™)
                    const offset = this.cubeSize + this.spacing;
                    mesh.position.set(x * offset, y * offset, z * offset);

                    // å„²å­˜é‚è¼¯åº§æ¨™ï¼Œæ–¹ä¾¿å¾ŒçºŒæŸ¥æ‰¾
                    mesh.userData = { x: x, y: y, z: z, isCubie: true };

                    // ç•«é»‘é‚Šæ¡†è®“æ–¹å¡Šæ›´æ˜é¡¯
                    const edges = new THREE.EdgesGeometry(geometry);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
                    mesh.add(line);

                    this.scene.add(mesh);
                    this.cubies.push(mesh);
                }
            }
        }
    }

    // æ ¹æ“šä½ç½®æ±ºå®šæè³ªé¡è‰²
    // Three.js BoxGeometry æè³ªé †åº: Right(+x), Left(-x), Top(+y), Bottom(-y), Front(+z), Back(-z)
    getMaterials(x, y, z) {
        const mats = [];
        // +x (Right): Red
        mats.push(new THREE.MeshStandardMaterial({ color: x === 1 ? this.colors.right : this.colors.core }));
        // -x (Left): Orange
        mats.push(new THREE.MeshStandardMaterial({ color: x === -1 ? this.colors.left : this.colors.core }));
        // +y (Top): Yellow
        mats.push(new THREE.MeshStandardMaterial({ color: y === 1 ? this.colors.top : this.colors.core }));
        // -y (Bottom): White
        mats.push(new THREE.MeshStandardMaterial({ color: y === -1 ? this.colors.bottom : this.colors.core }));
        // +z (Front): Green
        mats.push(new THREE.MeshStandardMaterial({ color: z === 1 ? this.colors.front : this.colors.core }));
        // -z (Back): Blue
        mats.push(new THREE.MeshStandardMaterial({ color: z === -1 ? this.colors.back : this.colors.core }));

        // èª¿æ•´æè³ªç²—ç³™åº¦ï¼Œè®“å®ƒçœ‹èµ·ä¾†åƒå¡‘è† 
        mats.forEach(m => {
            m.roughness = 0.5;
            m.metalness = 0.1;
        });

        return mats;
    }

    /**
     * æ ¸å¿ƒæ—‹è½‰é‚è¼¯
     * @param {String} axis - 'x', 'y', 'z' æ—‹è½‰è»¸
     * @param {Number} layer - -1 (å·¦/ä¸‹/å¾Œ), 0 (ä¸­), 1 (å³/ä¸Š/å‰)
     * @param {Number} direction - -1 (é †æ™‚é‡, è¦–è¦ºä¸Š), 1 (é€†æ™‚é‡) *æ³¨æ„ï¼šThree.js åº§æ¨™ç³»æ–¹å‘å¯èƒ½éœ€èª¿æ•´
     * * ä¿®æ­£æ–¹å‘å®šç¾©ä»¥ç¬¦åˆé­”æ–¹å…¬å¼æ…£ä¾‹ (çœ‹è‘—è©²é¢æ™‚ï¼Œé †æ™‚é‡ç‚ºæ­£):
     * U (Top, y=1): Look down Y axis.
     * D (Bottom, y=-1): Look up Y axis.
     * ...
     */
    rotateLayer(notation, dirMultiplier = -1) {
        if (this.isAnimating) return;

        // è§£æç¬¦è™Ÿ
        let axis, layer, angle;

        // æ ¹æ“šé­”æ–¹å…¬å¼è¨­å®š
        // é€™è£¡ç‚ºäº†ç°¡åŒ–ï¼ŒdirMultiplier -1 ä»£è¡¨é †æ™‚é‡æŒ‰éˆ•ï¼Œ1 ä»£è¡¨é€†æ™‚é‡ (Shift)
        // å¯¦éš›æ—‹è½‰è§’åº¦éœ€è¦æ ¹æ“šè»¸å‘èª¿æ•´
        const speed = 500; // å‹•ç•«æ™‚é–“ ms

        switch(notation) {
            case 'R': axis = 'x'; layer = 1; angle = -Math.PI/2 * dirMultiplier; break;
            case 'L': axis = 'x'; layer = -1; angle = Math.PI/2 * dirMultiplier; break;
            case 'U': axis = 'y'; layer = 1; angle = -Math.PI/2 * dirMultiplier; break;
            case 'D': axis = 'y'; layer = -1; angle = Math.PI/2 * dirMultiplier; break;
            case 'F': axis = 'z'; layer = 1; angle = -Math.PI/2 * dirMultiplier; break;
            case 'B': axis = 'z'; layer = -1; angle = Math.PI/2 * dirMultiplier; break;
            default: return;
        }

        this.isAnimating = true;

        // 1. æ‰¾å‡ºè©²å±¤çš„æ‰€æœ‰å°æ–¹å¡Š
        const activeCubies = this.cubies.filter(c => {
            // ç”±æ–¼æ—‹è½‰å¾Œåº§æ¨™æœƒæœ‰æµ®é»æ•¸èª¤å·®ï¼Œéœ€ç”¨ epsilon åˆ¤æ–·
            const pos = c.position[axis];
            // åˆ¤æ–·æ˜¯å¦åœ¨è©²å±¤ (è€ƒæ…®é–“è·ç¸®æ”¾ï¼ŒåŸå§‹é‚è¼¯åº§æ¨™æ˜¯ -1, 0, 1)
            // ç•¶å‰ä½ç½® / (size+spacing) å¤§ç´„ç­‰æ–¼ layer
            const rawPos = pos / (this.cubeSize + this.spacing);
            return Math.abs(rawPos - layer) < 0.1;
        });

        // 2. å°‡é€™äº›æ–¹å¡Š Attach åˆ° pivot
        this.pivot.rotation.set(0, 0, 0);
        this.pivot.position.set(0, 0, 0);
        this.pivot.updateMatrixWorld();

        activeCubies.forEach(c => {
            this.pivot.attach(c);
        });

        // 3. ä½¿ç”¨ Tween åŸ·è¡Œæ—‹è½‰å‹•ç•«
        const targetRotation = { value: angle };
        const currentRotation = { value: 0 };

        new TWEEN.Tween(currentRotation)
            .to(targetRotation, speed)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onUpdate(() => {
                this.pivot.rotation[axis] = currentRotation.value;
            })
            .onComplete(() => {
                // 4. å‹•ç•«çµæŸï¼ŒDetach ä¸¦æ›´æ–°ä¸–ç•Œåº§æ¨™
                this.pivot.updateMatrixWorld(); // ç¢ºä¿ pivot ç‹€æ…‹æœ€æ–°
                activeCubies.forEach(c => {
                    this.scene.attach(c); // ç§»å› sceneï¼Œæœƒè‡ªå‹•ä¿ç•™ä¸–ç•Œè®Šæ›

                    // 5. é—œéµï¼šæ ¡æ­£åº§æ¨™èˆ‡æ—‹è½‰ (SNAP to grid)
                    // é¿å…å¤šæ¬¡æ—‹è½‰å¾Œçš„æµ®é»æ•¸æ¼‚ç§»
                    c.position.x = Math.round(c.position.x / (this.cubeSize + this.spacing)) * (this.cubeSize + this.spacing);
                    c.position.y = Math.round(c.position.y / (this.cubeSize + this.spacing)) * (this.cubeSize + this.spacing);
                    c.position.z = Math.round(c.position.z / (this.cubeSize + this.spacing)) * (this.cubeSize + this.spacing);

                    c.rotation.x = Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2);
                    c.rotation.y = Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2);
                    c.rotation.z = Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2);

                    c.updateMatrix();
                });

                this.pivot.rotation.set(0,0,0);
                this.isAnimating = false;
            })
            .start();
    }

    // æ‰“äº‚åŠŸèƒ½
    scramble() {
        if (this.isAnimating) return;

        const moves = ['R', 'L', 'U', 'D', 'F', 'B'];
        const count = 20; // æ‰“äº‚æ­¥æ•¸
        let sequence = [];

        for(let i=0; i<count; i++) {
            const move = moves[Math.floor(Math.random() * moves.length)];
            const dir = Math.random() > 0.5 ? 1 : -1;
            sequence.push({ move, dir });
        }

        // å¿«é€ŸåŸ·è¡Œåºåˆ—
        // ç‚ºäº†ç°¡åŒ–ï¼Œé€™è£¡æˆ‘å€‘ä½¿ç”¨éè¿´å»¶é²åŸ·è¡Œï¼Œè®“ä½¿ç”¨è€…çœ‹å¾—åˆ°æ‰“äº‚éç¨‹
        let idx = 0;
        const nextMove = () => {
            if (idx >= sequence.length) return;
            const action = sequence[idx];

            // å¼·åˆ¶åŸ·è¡Œä¸€å€‹å¿«é€Ÿå‹•ç•«
            this.rotateLayer(action.move, action.dir);

            // ç›£è½å‹•ç•«çµæŸæ¨™è¨˜æœ‰é»éº»ç…©ï¼Œé€™è£¡ç°¡å–®ç”¨ timeout (éœ€é…åˆ rotateLayer çš„ speed)
            // ç‚ºäº†æ‰“äº‚å¿«ä¸€é»ï¼Œæˆ‘å€‘å¯ä»¥æš«æ™‚ä¿®æ”¹ TWEEN çš„é€Ÿåº¦ï¼Œæˆ–ç›´æ¥è¨­ç½®
            idx++;
            setTimeout(nextMove, 600); // æ¯”å‹•ç•«ç¨æ…¢ä¸€é»ç¢ºä¿å®‰å…¨
        };
        nextMove();
    }

    reset() {
        if (this.isAnimating) return;
        this.createCube();
    }

    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    onKeyDown(event) {
        if (this.isAnimating) return;

        const key = event.key.toUpperCase();
        const isShift = event.shiftKey;
        const dir = isShift ? 1 : -1; // Shift ç‚ºé€†æ™‚é‡

        if (['R', 'L', 'U', 'D', 'F', 'B'].includes(key)) {
            this.rotateLayer(key, dir);
        }
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        TWEEN.update();
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }
}

// åˆå§‹åŒ–æ‡‰ç”¨
window.onload = () => {
    window.cubeApp = new RubiksCubeApp();
};

</script>
</body>
</html>
